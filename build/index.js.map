{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from 'clean-stack'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nclass Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @constructor\n   * @param {Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n * @param {Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor({ er = erotic(true), ...options } = {}) {\n    super(options)\n    const { binary, rs } = options\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          const err = er(e)\n          j(err)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          j(e)\n        }\n      })\n      if (rs) {\n        rs.once('error', e => this.emit('error', e))\n        rs.pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise.<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\nexport default Catchment\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const readFile = async (path) => {\n *  const rs = createReadStream(path)\n *  const res = await collect()\n *  return res\n * }\n */\nexport const collect = async (readable, options = { binary: false }) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* documentary types/index.xml */\n/**\n * @typedef {import('stream').Readable} Readable\n *\n * @typedef {Object} Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n\n/* documentary types/collect.xml */\n/**\n * @typedef {import('stream').Readable} Readable\n *\n * @typedef {Object} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n"]}