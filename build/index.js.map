{"version":3,"sources":["../src/index.js"],"names":["joinBufferData","array","join","Catchment","Writable","constructor","options","binary","rs","_caughtData","_promise","Promise","r","j","on","d","Buffer","concat","pipe","_write","chunk","encoding","callback","push","promise"],"mappings":";;;;;;;AAAA;;AAEA,SAASA,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,SAAOA,MAAMC,IAAN,CAAW,EAAX,CAAP;AACD;;AAED,MAAMC,SAAN,SAAwBC,gBAAxB,CAAiC;AAC/B;;;;;;;;;;;;;;;;AAgBAC,cAAYC,UAAU,EAAtB,EAA0B;AACxB,UAAMA,OAAN;AACA,UAAM;AAAEC,YAAF;AAAUC;AAAV,QAAiBF,OAAvB;AACA,SAAKG,WAAL,GAAmB,EAAnB;AACA,SAAKC,QAAL,GAAgB,IAAIC,OAAJ,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACpC,WAAKC,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,YAAIC,CAAJ;;AACA,YAAIR,MAAJ,EAAY;AACVQ,cAAIC,OAAOC,MAAP,CAAc,KAAKR,WAAnB,CAAJ;AACD,SAFD,MAEO;AACLM,cAAIf,eAAe,KAAKS,WAApB,CAAJ;AACD;;AACDG,UAAEG,CAAF;AACA,aAAKN,WAAL,GAAmB,EAAnB;AACD,OATD;AAUA,WAAKK,EAAL,CAAQ,OAAR,EAAiBD,CAAjB;;AACA,UAAIL,EAAJ,EAAQ;AACNA,WAAGM,EAAH,CAAM,OAAN,EAAeD,CAAf;AACAL,WAAGU,IAAH,CAAQ,IAAR;AACD;AACF,KAhBe,CAAhB;AAiBD;;AACDC,SAAOC,KAAP,EAAcC,QAAd,EAAwBC,QAAxB,EAAkC;AAChC,SAAKb,WAAL,CAAiBc,IAAjB,CAAsBH,KAAtB;;AACAE;AACD;AACD;;;AACA,MAAIE,OAAJ,GAAc;AACZ,WAAO,KAAKd,QAAZ;AACD;;AA9C8B;AAiDjC;;;;;;;;eAOeP,S","sourcesContent":["import { Writable } from 'stream'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\nclass Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all\n   * emitted data.\n   * @constructor\n   * @param {Object} options Options to pass to `Writable` the super constructor, and other shown below.\n   * @param {Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs in that stream, the catchment promise will be rejected.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options = {}) {\n    super(options)\n    const { binary, rs } = options\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.on('error', j)\n      if (rs) {\n        rs.on('error', j)\n        rs.pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /** @type {Promise.<string|Buffer>} */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * @typedef {import('stream').Readable} Readable\n * @typedef {Object} Options Options to pass to `Writable` the super constructor, and other shown below.\n * @prop {Readable} rs A readable stream to automatically pipe into the catchment.\n * @prop {boolean} binary Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method.\n */\n\nexport default Catchment\n"],"file":"index.js"}